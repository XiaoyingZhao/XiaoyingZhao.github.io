<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="赵小金的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="赵小金">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="赵小金">
<meta property="og:description" content="赵小金的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="赵小金">
<meta name="twitter:description" content="赵小金的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>赵小金</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">赵小金</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">嗨~</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/25/nuxt/一、/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵小金">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵小金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/25/nuxt/一、/" itemprop="url">一、了解SSR</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-25T16:52:00+08:00">
                2020-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、SSR概念"><a href="#一、SSR概念" class="headerlink" title="一、SSR概念"></a>一、SSR概念</h3><p><strong>SSR</strong><br>server side render 服务端渲染</p>
<p><strong>客户端渲染</strong><br>页面初始加载的 HTML 页面中无网页展示内容，需要加载执行Js代码，通过 js 渲染生成页面。比较代表性的为React,Vue,Angular三大前端框架的SPA(Single Page Application)应用。</p>
<p><strong>服务端渲染</strong><br>用户请求服务器，服务器上直接生成 HTML 内容并返回给浏览器。客户端所需要做的仅仅是html页面的展现和之后的DOM事件处理。代表为传统的JSP,PHP,ASP应用。</p>
<p><strong>同构</strong><br>同构这个概念存在于 Vue，React 这些新型的前端框架中，同构实际上是客户端渲染和服务器端渲染的一个整合。两端共用一套代码，只是采用不通的构建方式；在加载首屏的时候，执行服务端代码，页面渲染和请求js同时进行。从首屏进入第二页时就不请求服务端代码了，直接执行Vue的路由跳转。<br>（这里首屏的概念不是首页，而是用户打开的第一页，例如：A打开司机招聘的首页，点击其中一条详情进入详情页，然后将详情页分享给B，B打开的是详情页。这里A的首屏是首页，B的首屏是详情页）</p>
<h3 id="二、使用SSR的利弊"><a href="#二、使用SSR的利弊" class="headerlink" title="二、使用SSR的利弊"></a>二、使用SSR的利弊</h3><h4 id="SSR的优势"><a href="#SSR的优势" class="headerlink" title="SSR的优势"></a>SSR的优势</h4><ol>
<li>更利于SEO<br>爬虫只会爬取源码，不会执行网站的任何脚本（Google除外，Google等页面加载完之后再去爬取内容，所以Google的爬虫可以爬取单页面应用）</li>
<li>更利于首屏渲染<br>首屏的渲染是node发送过来的html字符串，并不依赖于js文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。</li>
</ol>
<h4 id="SSR的局限"><a href="#SSR的局限" class="headerlink" title="SSR的局限"></a>SSR的局限</h4><ol>
<li>服务端压力较大<br>本来是通过客户端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端CPU资源；</li>
<li>开发条件受限<br>服务端代与客户端共用一套代码，但是执行周期不一致</li>
<li>学习成本相对较高<br>还需要掌握node、Koa2等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。</li>
</ol>
<h3 id="三、介绍NUXT"><a href="#三、介绍NUXT" class="headerlink" title="三、介绍NUXT"></a>三、介绍NUXT</h3><p> <a href="https://zh.nuxtjs.org/" target="_blank" rel="noopener">nuxt官网</a></p>
<h4 id="nuxt的优点："><a href="#nuxt的优点：" class="headerlink" title="nuxt的优点："></a>nuxt的优点：</h4><ul>
<li>基于 Vue.js</li>
<li>自动代码分层</li>
<li>服务端渲染</li>
<li>强大的路由功能，支持异步数据</li>
<li>静态文件服务</li>
<li>ES2015+ 语法支持</li>
<li>打包和压缩 JS 和 CSS</li>
<li>HTML 头部标签管理</li>
<li>本地开发支持热加载</li>
<li>集成 ESLint</li>
<li>支持各种样式预处理器： SASS、LESS、 Stylus 等等</li>
<li>支持 HTTP/2 推送</li>
</ul>
<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p>下图阐述了 Nuxt.js 应用一个完整的服务器请求到渲染（或用户通过 <code>&lt;nuxt-link&gt;</code>切换路由渲染页面）的流程：<br><img src="/2020/03/25/nuxt/一、/zhouqi.webp" alt="image"><br>生命周期流程图，红框内的是Nuxt的生命周期(运行在<code>服务端</code>)，黄框内<code>同时运行在服务端&amp;&amp;客户端</code>上，绿框内则运行在<code>客户端</code></p>
<ol>
<li>红框、黄框内的周期都不存在Window,document,navigator对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  asyncData() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>) <span class="comment">// 服务端报错</span></span><br><span class="line">  &#125;,</span><br><span class="line">  fetch() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>) <span class="comment">// 服务端报错</span></span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>) <span class="comment">// undefined</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>) <span class="comment">// Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="三、开始"><a href="#三、开始" class="headerlink" title="三、开始"></a>三、开始</h3><p>1、运行一个NUXT项目<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx create-nuxt-app abc</span><br></pre></td></tr></table></figure></p>
<p>我的电脑运行这条命令慢的出奇，所以我用了另一种方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g @vue/cli-init</span><br><span class="line"><span class="comment">// 如果已安装过vue-cli可以不用执行上面这条</span></span><br><span class="line">$ vue init nuxt/starter abc</span><br></pre></td></tr></table></figure></p>
<p><img src="/2020/03/25/nuxt/一、/img1.jpg" alt="image"><br>2、启动项目<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd abc</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br><span class="line"><span class="comment">// 在浏览器里执行：`http://localhost:3000/`</span></span><br></pre></td></tr></table></figure></p>
<p>这时项目中会多一个.nuxt的文件</p>
<p><img src="/2020/03/25/nuxt/一、/img2.jpg" alt="image"></p>
<p>3、打包<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></p>
<p>这时看到.nuxt中的文件变了，并且多了一个dist文件夹（这里有一个坑，通常我们的.gitignore文件会忽略dist文件，这里要注意）<br><img src="/2020/03/25/nuxt/一、/img3.jpg" alt="image"></p>
<p>4、目录详解<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">|-- .nuxt                            <span class="comment">// Nuxt运行时自动生成，和build之后的代码</span></span><br><span class="line">|-- assets                           <span class="comment">// 资源目录 assets 用于组织未编译的静态资源如 LESS、SASS 或 JavaScript</span></span><br><span class="line">|-- components                       <span class="comment">// 用于自己编写的Vue组件，比如滚动组件，日历组件，分页组件</span></span><br><span class="line">|-- layouts                          <span class="comment">// 布局目录，用于组织应用的布局组件，不可更改。</span></span><br><span class="line">|-- middleware                       <span class="comment">// 用于存放中间件</span></span><br><span class="line">|-- pages                            <span class="comment">// 用于存放写的页面，我们主要的工作区域</span></span><br><span class="line">|-- plugins                          <span class="comment">// 用于存放JavaScript插件的地方</span></span><br><span class="line">|-- <span class="keyword">static</span>                           <span class="comment">// 用于存放静态资源文件，比如图片</span></span><br><span class="line">|-- store                            <span class="comment">// 用于组织应用的Vuex 状态管理。</span></span><br><span class="line">|-- .editorconfig                    <span class="comment">// 开发工具格式配置</span></span><br><span class="line">|-- .eslintrc.js                     <span class="comment">// ESLint的配置文件，用于检查代码格式</span></span><br><span class="line">|-- .gitignore                       <span class="comment">// 配置git不上传的文件</span></span><br><span class="line">|-- nuxt.config.js                   <span class="comment">// 用于组织Nuxt.js应用的个性化配置，已覆盖默认配置</span></span><br><span class="line">|-- package-lock.json                <span class="comment">// npm自动生成，用于帮助package的统一性设置的，yarn也有相同的操作</span></span><br><span class="line">|-- package-lock.json                <span class="comment">// npm自动生成，用于帮助package的统一性设置的，yarn也有相同的操作</span></span><br><span class="line">|-- package.json                     <span class="comment">// npm包管理配置文件</span></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/用 npm script 打造超溜的前端工作流/实战篇 05：用 npm script 实现服务自动化运维/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵小金">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵小金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/17/用 npm script 打造超溜的前端工作流/实战篇 05：用 npm script 实现服务自动化运维/" itemprop="url">4.5 使用 npm script 进行服务运维</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-17T11:11:42+08:00">
                2020-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/npm-script/" itemprop="url" rel="index">
                    <span itemprop="name">npm script</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="4-5-使用-npm-script-进行服务运维"><a href="#4-5-使用-npm-script-进行服务运维" class="headerlink" title="4.5 使用 npm script 进行服务运维"></a>4.5 使用 npm script 进行服务运维</h1><p>需要事先说明的是，本节部分内容涉及到非前端的话题，比如服务的部署、日志，但会从前端项目管理开始，比如依赖管理、版本管理等。即使对自己定位是纯粹前端开发的同学，也建议阅读下，因为技不压身，了解整个前端项目交付流程中需要考量的点能让我们更有大局观。</p>
<p>通常来说，项目构建完成之后，就成为待发布的版本，因此版本管理需要考虑，甚至做成自动化的，然后，最新的代码需要部署到线上机器才能让所有用户访问到，部署环节涉及到服务的启动、重启、日志管理等需要考虑。</p>
<p>下面我们介绍 npm script 在服务运维时的几个用途：</p>
<h2 id="使用-npm-script-进行版本管理"><a href="#使用-npm-script-进行版本管理" class="headerlink" title="使用 npm script 进行版本管理"></a>使用 npm script 进行版本管理</h2><p>每次构建完的代码都应该有新的版本号，修改版本号直接使用 npm 内置的 version 自命令即可，如果是简单粗暴的版本管理，可以在 package.json 中添加如下 scripts：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+    &quot;release:patch&quot;: &quot;npm version patch &amp;&amp; git push &amp;&amp; git push --tags&quot;,</span><br><span class="line">+    &quot;release:minor&quot;: &quot;npm version minor &amp;&amp; git push &amp;&amp; git push --tags&quot;,</span><br><span class="line">+    &quot;release:major&quot;: &quot;npm version major &amp;&amp; git push &amp;&amp; git push --tags&quot;,</span><br><span class="line">     &quot;precommit&quot;: &quot;lint-staged&quot;,</span><br></pre></td></tr></table></figure>
<p>这 3 条命令遵循 <a href="https://semver.org" target="_blank" rel="noopener">semver</a> 的版本号规范来方便你管理版本，patch 是更新补丁版本，minor 是更新小版本，major 是更新大版本。在必要的时候，可以通过运行 npm run version:patch 来升补丁版本，运行输出如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/18/16066e6e3d85b6cd?w=910&amp;h=943&amp;f=png&amp;s=144886" alt="img"></p>
<p>如果要求所有的版本号不超过 10，即 0.0.9 的下个版本是 0.1.0 而不是 0.0.10，可以编写简单的 shell 脚本来实现（<strong>注意这样会破坏 semver 的约定</strong>），具体步骤如下：</p>
<p>首先，在 scripts 目录下新增 bump.sh（<strong>别忘了文件的可执行权限</strong>：chmod a+x scripts/bump.sh）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line"># get major/minor/patch version to change</span><br><span class="line">version=`cat package.json| grep version | grep -v release | awk -F\&quot; &apos;&#123;print $4&#125;&apos;`</span><br><span class="line">components=($(echo $version | tr &apos;.&apos; &apos;\n&apos;))</span><br><span class="line">major=$&#123;components[0]&#125;</span><br><span class="line">minor=$&#123;components[1]&#125;</span><br><span class="line">patch=$&#123;components[2]&#125;</span><br><span class="line"></span><br><span class="line">release=&apos;patch&apos;;</span><br><span class="line"></span><br><span class="line"># decide which version to increment</span><br><span class="line">if [ $patch -ge 9 ]; then</span><br><span class="line">    if [ $minor -ge 9 ]; then</span><br><span class="line">        release=&apos;major&apos;</span><br><span class="line">    else</span><br><span class="line">        release=&apos;minor&apos;</span><br><span class="line">    fi</span><br><span class="line">else</span><br><span class="line">    release=&apos;patch&apos;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;major=$major, minor=$minor, patch=$patch, release=$release&quot;</span><br><span class="line"></span><br><span class="line"># upgrade version</span><br><span class="line">npm run release:$release</span><br></pre></td></tr></table></figure>
<p>然后，在 package.json 中新增 bump 子命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     &quot;release:major&quot;: &quot;npm version major &amp;&amp; git push &amp;&amp; git push --tags&quot;,</span><br><span class="line">+    &quot;bump&quot;: &quot;scripty&quot;,</span><br><span class="line">     &quot;precommit&quot;: &quot;lint-staged&quot;,</span><br></pre></td></tr></table></figure>
<p>在必要的时候执行 npm run bump，输出示例如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/18/16066e70eb4a0193?w=1001&amp;h=1143&amp;f=png&amp;s=165735" alt="img"></p>
<h2 id="使用-npm-script-进行服务进程和日志管理"><a href="#使用-npm-script-进行服务进程和日志管理" class="headerlink" title="使用 npm script 进行服务进程和日志管理"></a>使用 npm script 进行服务进程和日志管理</h2><p>在生产环境的服务进程和日志管理领域，<a href="http://pm2.keymetrics.io" target="_blank" rel="noopener">pm2</a> 是当之无愧的首选，功能很强大，使用简单，开发环境常用的是 <a href="https://www.npmjs.com/package/nodemon" target="_blank" rel="noopener">nodemon</a>。</p>
<p>在我们的项目中使用 npm script 进行服务进程和日志管理的基本步骤如下：</p>
<h3 id="1-准备-http-服务"><a href="#1-准备-http-服务" class="headerlink" title="1. 准备 http 服务"></a>1. 准备 http 服务</h3><p>在使用 npm script 作为构建流水线的基础上，我们在项目中引入了 <a href="https://www.npmjs.com/package/express" target="_blank" rel="noopener">express</a> 和 <a href="https://www.npmjs.com/package/morgan" target="_blank" rel="noopener">morgan</a>，并使用如下脚本启动 http 服务器方便用户访问我们的网页（morgan 使用来记录用户的访问日志的）：</p>
<p>先安装依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i express morgan -D</span><br><span class="line"># npm install express morgan --save-dev</span><br><span class="line"># yarn add express morgan -D</span><br></pre></td></tr></table></figure>
<p>然后在根目录下创建文件 server.js，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const morgan = require(&apos;morgan&apos;);</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line">const port = process.env.PORT || 8080;</span><br><span class="line"></span><br><span class="line">app.use(express.static(&apos;./dist&apos;));</span><br><span class="line">app.use(morgan(&apos;combined&apos;));</span><br><span class="line"></span><br><span class="line">app.listen(port, err =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.error(&apos;server start error&apos;, err); // eslint-disable-line</span><br><span class="line">    process.exit(1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  console.log(`server started at port $&#123;port&#125;`);  // eslint-disable-line</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2-准备日志目录"><a href="#2-准备日志目录" class="headerlink" title="2. 准备日志目录"></a>2. 准备日志目录</h3><p>为简单起见，我们项目中创建日志存储目录 logs，有些公司可能不会把日志存在项目部署目录下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir logs</span><br><span class="line">touch logs/.gitkeep</span><br><span class="line">git add logs/.gitkeep</span><br><span class="line">git commit -m &apos;add logs folder&apos;</span><br></pre></td></tr></table></figure>
<p>并且设置该目录为 git 忽略的，再改动 .gitignore：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> dist</span><br><span class="line">+logs</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>TIP#21</strong>：这里加 logs/.gitkeep 空文件的目的是为了能把 logs 目录提交到 git 里面，但是我们故意忽略 logs 目录里面的内容，这是在 git 中提交目录结构而忽略其中内容的常见做法。</p>
</blockquote>
<h3 id="3-安装和配置-pm2"><a href="#3-安装和配置-pm2" class="headerlink" title="3. 安装和配置 pm2"></a>3. 安装和配置 pm2</h3><p>安装 pm2 作为依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i pm2 -D</span><br><span class="line"># npm install pm2 --save-dev</span><br><span class="line"># yarn add pm2 -D</span><br></pre></td></tr></table></figure>
<p>然后添加服务启动配置到项目根目录下 pm2.json，更多配置项可以参照<a href="http://pm2.keymetrics.io/docs/usage/application-declaration" target="_blank" rel="noopener">文档</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;apps&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;npm-script-workflow&quot;,</span><br><span class="line">      &quot;script&quot;: &quot;./server.js&quot;,</span><br><span class="line">      &quot;out_file&quot;: &quot;./logs/stdout.log&quot;,</span><br><span class="line">      &quot;error_file&quot;: &quot;./logs/stderr.log&quot;,</span><br><span class="line">      &quot;log_date_format&quot;: &quot;YYYY-MM-DD HH:mm:ss&quot;,</span><br><span class="line">      &quot;instances&quot;: 0,</span><br><span class="line">      &quot;exec_mode&quot;: &quot;cluster&quot;,</span><br><span class="line">      &quot;max_memory_restart&quot;: &quot;800M&quot;,</span><br><span class="line">      &quot;merge_logs&quot;: true,</span><br><span class="line">      &quot;env&quot;: &#123;</span><br><span class="line">        &quot;NODE_ENV&quot;: &quot;production&quot;,</span><br><span class="line">        &quot;PORT&quot;: 8080,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的配置指定了服务脚本为 server.js，日志输出文件路径，日志时间格式，进程数量 = CPU 核数，启动方式为 cluster，以及两个环境变量。</p>
<h3 id="4-配置服务部署命令"><a href="#4-配置服务部署命令" class="headerlink" title="4. 配置服务部署命令"></a>4. 配置服务部署命令</h3><p>在没有集成 CI 服务之前，我们的部署命令应该是下面这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     &quot;release:major&quot;: &quot;npm version major &amp;&amp; git push &amp;&amp; git push --tags&quot;,</span><br><span class="line">+    &quot;predeploy&quot;: &quot;yarn &amp;&amp; npm run build&quot;,</span><br><span class="line">+    &quot;deploy&quot;: &quot;pm2 restart pm2.json&quot;,</span><br><span class="line">     &quot;bump&quot;: &quot;scripty&quot;,</span><br></pre></td></tr></table></figure>
<p>即在部署前需要安装最新的依赖，重新构建，然后使用 pm2 重新启动服务即可，如果你有多台机器跑通1个服务，建议有个集中的 CI 服务器专门负责构建，而部署时就不需要运行 build 了。</p>
<p>每次需要部署服务时只需要运行 npm run deploy 就行了，运行成功输出如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/18/16066e77ad30626c?w=1146&amp;h=186&amp;f=png&amp;s=42916" alt="img"></p>
<h3 id="5-配置日志查看命令"><a href="#5-配置日志查看命令" class="headerlink" title="5. 配置日志查看命令"></a>5. 配置日志查看命令</h3><p>至于日志，虽然 pm2 提供了内置的 logs 管理命令，如果某台服务器上启动了多个不同的服务进程，那么 pm2 logs 会展示所有服务的日志，个人建议使用如下命令查看当前服务的日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+    &quot;logs&quot;: &quot;tail -f logs/*&quot;,</span><br><span class="line">     &quot;bump&quot;: &quot;scripty&quot;,</span><br></pre></td></tr></table></figure>
<p>需要查看日志时，直接运行 npm run logs，运行输入如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/18/16066e7b80b6d828?w=1271&amp;h=354&amp;f=png&amp;s=80687" alt="img"></p>
<p>当然如果你有更复杂的日志查看需求，直接用 cat、grep 之类的命令好了。</p>
<blockquote>
<p><strong>到这里，小册的内容基本结束了，接下来的一周，我会准备好视频版教程，在圣诞节的时候放出来给大家。如果你对内容有任何疑问，欢迎留言或者在读者群里面交流</strong></p>
</blockquote>
<hr>
<blockquote>
<p>本节用到的代码见 <a href="https://github.com/wangshijun/automated-workflow-with-npm-script/tree/13-use-npm-script-for-devops" target="_blank" rel="noopener">GitHub</a>，想边看边动手练习的同学可以拉下来自己改，注意切换到正确的分支 <code>13-use-npm-script-for-devops</code>。</p>
</blockquote>
<hr>
<blockquote>
<p><strong>视频版教程已经录制完毕，下载地址：链接: <a href="https://pan.baidu.com/s/1gfeZ619" target="_blank" rel="noopener">https://pan.baidu.com/s/1gfeZ619</a> 密码: xx8j，请享用</strong></p>
</blockquote>
<hr>
<p>** 对于购买了小册，没有加到读者群里面的同学，可以加我微信：feweekly，备注：掘金小册，我会拉你入群。感谢支持！**</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/用 npm script 打造超溜的前端工作流/实战篇 04：用 npm script 实现构建流水线/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵小金">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵小金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/17/用 npm script 打造超溜的前端工作流/实战篇 04：用 npm script 实现构建流水线/" itemprop="url">4.4 使用 npm script 实现构建流水线</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-17T11:11:41+08:00">
                2020-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/npm-script/" itemprop="url" rel="index">
                    <span itemprop="name">npm script</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="4-4-使用-npm-script-实现构建流水线"><a href="#4-4-使用-npm-script-实现构建流水线" class="headerlink" title="4.4 使用 npm script 实现构建流水线"></a>4.4 使用 npm script 实现构建流水线</h1><p>在现代前端项目的交付工作流中，部署前最关键的环节就是构建，构建环节要完成的事情通常包括：</p>
<ul>
<li>源代码预编译：比如 less、sass、typescript；</li>
<li>图片优化、雪碧图生成；</li>
<li>JS、CSS 合并、压缩；</li>
<li>静态资源加版本号和引用替换；</li>
<li>静态资源传 CDN 等。</li>
</ul>
<p>现在大多数同学所接触的项目构建过程可能都是别人配置好的，但是对于构建过程中的某些考量可能并不是很清楚。</p>
<p>接下来，我们将组合 npm script 和简单的命令行工具为实际项目添加构建过程，以加深对构建过程的理解，同时也会用到前面很多章节的知识点。</p>
<h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><p>对之前的示例项目做简单改造，让目录结构包括典型的前端项目资源引用情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">client</span><br><span class="line">├── images</span><br><span class="line">│   └── schedule.png</span><br><span class="line">├── index.html</span><br><span class="line">├── scripts</span><br><span class="line">│   └── main.js</span><br><span class="line">└── styles</span><br><span class="line">    └── main.css</span><br></pre></td></tr></table></figure>
<p>可能的资源依赖关系如下：</p>
<ul>
<li>css、html 文件中引用了图片；</li>
<li>html 文件中引用了 css、js；</li>
</ul>
<p>显而易见，我们的构建过程必须遵循下面的步骤才能不出错：</p>
<ol>
<li>压缩图片；</li>
<li>编译 less、压缩 css；</li>
<li>编译、压缩 js；</li>
<li>给图片加版本号并替换 js、css 中的引用；</li>
<li>给 js、css 加版本号并替换 html 中的引用；</li>
</ol>
<h2 id="添加构建过程"><a href="#添加构建过程" class="headerlink" title="添加构建过程"></a>添加构建过程</h2><p>下面介绍如何结合 npm script 正确的给这样的项目结构加上构建过程。</p>
<h3 id="1-准备构建目录"><a href="#1-准备构建目录" class="headerlink" title="1. 准备构建目录"></a>1. 准备构建目录</h3><p>我们约定构建产生的结果代码，放在 dist 目录下，与 client 的结构完全相同，每次构建前，清空之前的构建目录，利用 npm 的钩子机制添加 prebuild 命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-    &quot;client:static-server&quot;: &quot;http-server client/&quot;</span><br><span class="line">+    &quot;client:static-server&quot;: &quot;http-server client/&quot;,</span><br><span class="line">+    &quot;prebuild&quot;: &quot;rm -rf dist &amp;&amp; mkdir -p dist/&#123;images,styles,scripts&#125;&quot;,</span><br></pre></td></tr></table></figure>
<h3 id="2-准备脚本目录"><a href="#2-准备脚本目录" class="headerlink" title="2. 准备脚本目录"></a>2. 准备脚本目录</h3><p>构建过程需要的命令稍长，我们可以使用 scripty 来把这些脚本剥离到单独的文件中，为此需要准备单独的目录，并且我们的构建过程分为：images、styles、scripts、hash 四个步骤，每个步骤准备单独的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir scripts/build</span><br><span class="line">touch scripts/build.sh</span><br><span class="line">touch scripts/build/&#123;images,styles,scripts&#125;.sh</span><br><span class="line">chmod -R a+x scripts</span><br></pre></td></tr></table></figure>
<p><strong>脚本文件的可执行权限必须添加正确，否则 scripty 会直接报错</strong>，上面命令执行完之后，scripts 目录包含如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scripts</span><br><span class="line">├── build</span><br><span class="line">│   ├── hash.sh</span><br><span class="line">│   ├── images.sh</span><br><span class="line">│   ├── scripts.sh</span><br><span class="line">│   └── styles.sh</span><br><span class="line">├── build.sh</span><br></pre></td></tr></table></figure>
<h3 id="3-图片构建过程"><a href="#3-图片构建过程" class="headerlink" title="3. 图片构建过程"></a>3. 图片构建过程</h3><p>图片构建的经典工具是 <a href="https://github.com/imagemin/imagemin" target="_blank" rel="noopener">imagemin</a>，它也提供了命令行版本 <a href="https://github.com/imagemin/imagemin-cli" target="_blank" rel="noopener">imagemin-cli</a>，首先安装依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i imagemin-cli -D</span><br><span class="line"># npm install imagemin-cli --save-dev</span><br><span class="line"># yarn add imagemin-cli -D</span><br></pre></td></tr></table></figure>
<p>然后在 scripts/build/images.sh 中添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imagemin client/images/* --out-dir=dist/images</span><br></pre></td></tr></table></figure>
<p>然后在 package.json 中添加 build:images 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+    &quot;build:images&quot;: &quot;scripty&quot;,</span><br></pre></td></tr></table></figure>
<p>尝试运行 npm run prebuild &amp;&amp; npm run build:images，然后观察 dist 目录的变化。</p>
<h3 id="4-样式构建过程"><a href="#4-样式构建过程" class="headerlink" title="4. 样式构建过程"></a>4. 样式构建过程</h3><p>我们使用 <a href="http://lesscss.org/usage/" target="_blank" rel="noopener">less</a> 编写样式，所以需要预编译样式代码，可以使用 less 官方库自带的命令行工具 lessc，使用 sass 的同学可以直接使用 <a href="https://github.com/sass/node-sass" target="_blank" rel="noopener">node-sass</a>。此外，样式预编译完成之后，我们需要使用 <a href="https://www.npmjs.com/package/cssmin" target="_blank" rel="noopener">cssmin</a> 来完成代码预压缩。首先安装依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i cssmin -D</span><br><span class="line"># npm install cssmin --save-dev</span><br><span class="line"># yarn add cssmin -D</span><br></pre></td></tr></table></figure>
<p>然后在 scripts/build/styles.sh 中添加如下内容，这里我们使用到了 shell 里面的管道操作符 <code>|</code> 和输出重定向 <code>&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for file in client/styles/*.css</span><br><span class="line">do</span><br><span class="line">  lessc $file | cssmin &gt; dist/styles/$(basename $file)</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>然后在 package.json 中添加 build:styles 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+    &quot;build:styles&quot;: &quot;scripty&quot;,</span><br></pre></td></tr></table></figure>
<p>尝试运行 npm run prebuild &amp;&amp; npm run build:styles，然后观察 dist 目录的变化，应该能看到 less 编译之后再被压缩的 css 代码。</p>
<h3 id="4-JS-构建过程"><a href="#4-JS-构建过程" class="headerlink" title="4. JS 构建过程"></a>4. JS 构建过程</h3><p>我们使用 ES6 编写 JS 代码，所以需要 <a href="https://github.com/mishoo/UglifyJS2/tree/harmony" target="_blank" rel="noopener">uglify-es</a> 来进行代码压缩，如果你不使用 ES6，可以直接使用 <a href="https://github.com/mishoo/UglifyJS2" target="_blank" rel="noopener">uglify-js</a> 来压缩代码，首先安装依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i uglify-es -D</span><br><span class="line"># npm install uglify-es --save-dev</span><br><span class="line"># yarn add uglify-es -D</span><br></pre></td></tr></table></figure>
<p>然后在 scripts/build/scripts.sh 中添加如下内容，<strong>需要额外注意的是，这里我们需要手动指定 uglify-es 目录下的 bin 文件，否则识别不了 ES6 语法</strong>，因为 uglify-es 在 npm install 过程自动创建的软链是错误的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for file in client/scripts/*.js</span><br><span class="line">do</span><br><span class="line">  ./node_modules/uglify-es/bin/uglifyjs $file --mangle &gt; dist/scripts/$(basename $file)</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>然后在 package.json 中添加 build:scripts 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+    &quot;build:scripts&quot;: &quot;scripty&quot;,</span><br></pre></td></tr></table></figure>
<p>尝试运行 npm run prebuild &amp;&amp; npm run build:scripts，然后观察 dist 目录的变化，应该能看到被 uglify-es 压缩后的代码。</p>
<blockquote>
<p><strong>TIP#19</strong>：uglify-es 支持很多其他的选项，以及 sourcemap，对 JS 代码做极致的优化，详细<a href="https://github.com/mishoo/UglifyJS2/tree/harmony#command-line-options" target="_blank" rel="noopener">参考</a></p>
</blockquote>
<h3 id="4-资源版本号和引用替换"><a href="#4-资源版本号和引用替换" class="headerlink" title="4. 资源版本号和引用替换"></a>4. 资源版本号和引用替换</h3><p>给静态资源加版本号的原因是线上环境的静态资源通常都放在 CDN 上，或者设置了很长时间的缓存，或者两者兼有，如果资源更新了但没有更新版本号，浏览器端是拿不到最新内容的，手动加版本号的过程很繁琐并且容易出错，为此自动化这个过程就显得非常有价值，通常的做法是利用文件内容做哈希，比如 md5，然后以这个哈希值作为版本号，版本号附着在文件名里面，线上环境的资源引用全部是带版本号的。</p>
<p>为了实现这个过程，我们需要引入两个小工具：</p>
<ul>
<li><a href="https://github.com/keithamus/hashmark" target="_blank" rel="noopener">hashmark</a>，自动添加版本号；</li>
<li><a href="https://github.com/songkick/replaceinfiles" target="_blank" rel="noopener">replaceinfiles</a>，自动完成引用替换，它需要将版本号过程的输出作为输入；</li>
</ul>
<p>首先安装依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i hashmark replaceinfiles -D</span><br><span class="line"># npm install hashmark replaceinfiles --save-dev</span><br><span class="line"># yarn add hashmark replaceinfiles -D</span><br></pre></td></tr></table></figure>
<p>然后在 scripts/build/hash.sh 中添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 给图片资源加上版本号，并且替换引用</span><br><span class="line">hashmark -c dist -r -l 8 &apos;**/*.&#123;png,jpg&#125;&apos; &apos;&#123;dir&#125;/&#123;name&#125;.&#123;hash&#125;&#123;ext&#125;&apos; | replaceinfiles -S -s &apos;dist/**/*.css&apos; -d &apos;&#123;dir&#125;/&#123;base&#125;&apos;</span><br><span class="line"></span><br><span class="line"># 给 js、css 资源加上版本号，并且替换引用</span><br><span class="line">hashmark -c dist -r -l 8 &apos;**/*.&#123;css,js&#125;&apos; &apos;&#123;dir&#125;/&#123;name&#125;.&#123;hash&#125;&#123;ext&#125;&apos; | replaceinfiles -S -s &apos;client/index.html&apos; -d &apos;dist/index.html&apos;</span><br></pre></td></tr></table></figure>
<p>然后在 package.json 中添加 build:hash 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+    &quot;build:hash&quot;: &quot;scripty&quot;,</span><br></pre></td></tr></table></figure>
<p>这个步骤需要依赖前几个步骤，不能单独运行，接下来我们需要增加完整的 build 命令把上面几个步骤串起来。</p>
<h3 id="5-完整的构建步骤"><a href="#5-完整的构建步骤" class="headerlink" title="5. 完整的构建步骤"></a>5. 完整的构建步骤</h3><p>最后我们在 package.json 中添加 build 命令把所有的步骤串起来，完整的 diff 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-    &quot;client:static-server&quot;: &quot;http-server client/&quot;</span><br><span class="line">+    &quot;client:static-server&quot;: &quot;http-server client/&quot;,</span><br><span class="line">+    &quot;prebuild&quot;: &quot;rm -rf dist &amp;&amp; mkdir -p dist/&#123;images,styles,scripts&#125;&quot;,</span><br><span class="line">+    &quot;build&quot;: &quot;scripty&quot;,</span><br><span class="line">+    &quot;build:images&quot;: &quot;scripty&quot;,</span><br><span class="line">+    &quot;build:scripts&quot;: &quot;scripty&quot;,</span><br><span class="line">+    &quot;build:styles&quot;: &quot;scripty&quot;,</span><br><span class="line">+    &quot;build:hash&quot;: &quot;scripty&quot;</span><br></pre></td></tr></table></figure>
<p>其中 scripts/build.sh 的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for step in &apos;images&apos; &apos;scripts&apos; &apos;styles&apos; &apos;hash&apos;</span><br><span class="line">do</span><br><span class="line">  npm run build:$step</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>然后我们尝试运行 npm run build，完整的过程输出如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/18/16066e5912427543?w=984&amp;h=1290&amp;f=png&amp;s=171783" alt="img"></p>
<p>构建完成的 dist 目录内容如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/18/16066e5b824399a7?w=698&amp;h=240&amp;f=png&amp;s=25460" alt="img"></p>
<p>可以看到，所有的静态资源都加上了版本号。</p>
<p>构建完成的 dist/index.html 内容如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/18/16066e5e1a91e46c?w=875&amp;h=416&amp;f=png&amp;s=74207" alt="img"></p>
<p>可以看到，静态资源的版本号被正确替换了，为了验证构建出来的页面是否正常运行，可以运行 <code>./node_modules/.bin/http-server dist</code>，然后浏览器打开：<code>http://127.0.0.1:8080</code>，不出意外的话，浏览器显示如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/18/16066e60258d8eeb?w=865&amp;h=688&amp;f=png&amp;s=192586" alt="img"></p>
<blockquote>
<p><strong>好了，到这里，我们给简单但是五脏俱全的前端项目加上了构建过程，这些环节你是否都清楚？你觉得还缺失些什么环节？欢迎留言交流</strong></p>
</blockquote>
<hr>
<blockquote>
<p>本节用到的代码见 <a href="https://github.com/wangshijun/automated-workflow-with-npm-script/tree/12-use-npm-script-as-build-pipeline" target="_blank" rel="noopener">GitHub</a>，想边看边动手练习的同学可以拉下来自己改，注意切换到正确的分支 <code>12-use-npm-script-as-build-pipeline</code>。</p>
</blockquote>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/用 npm script 打造超溜的前端工作流/实战篇 03：在 git hooks 中运行 npm script/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵小金">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵小金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/17/用 npm script 打造超溜的前端工作流/实战篇 03：在 git hooks 中运行 npm script/" itemprop="url">4.2 在 Git Hooks 中执行 npm script</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-17T11:11:40+08:00">
                2020-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/npm-script/" itemprop="url" rel="index">
                    <span itemprop="name">npm script</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="4-2-在-Git-Hooks-中执行-npm-script"><a href="#4-2-在-Git-Hooks-中执行-npm-script" class="headerlink" title="4.2 在 Git Hooks 中执行 npm script"></a>4.2 在 Git Hooks 中执行 npm script</h1><p>严肃的研发团队都会使用 Git 之类的版本管理系统来管理代码，随着 GitHub 的广受欢迎，相信大家对 Git 并不陌生。Git 在代码版本管理之外，也提供了类似 npm script 里 <code>pre</code>、<code>post</code> 的钩子机制，叫做 <a href="https://git-scm.com/book/gr/v2/Customizing-Git-Git-Hooks" target="_blank" rel="noopener">Git Hooks</a>，钩子机制能让我们在代码 commit、push 之前（后）做自己想做的事情。</p>
<p>Git Hooks 能给我们的开发工作流带来哪些可能呢？我带的团队中，大部分项目通过 npm script 为本地仓库配置了 pre-commit、pre-push 钩子检查，且正计划为远程仓库（<a href="https://git-scm.com/book/en/v1/Git-Basics-Working-with-Remotes" target="_blank" rel="noopener">Remotes</a>）配置 pre-receive 钩子检查。两种钩子的检查目的各不相同，本地检查是为了尽早给提交代码的同学反馈，哪些地方不符合规范，哪些地方需要注意；而远程检查是为了确保远程仓库收到的代码是符合团队约定的规范的，因为如果没有远程检查环节，熟悉 Git 的同学使用 <code>--no-verify</code>（简写为 <code>-n</code>） 参数跳过本地检查时，本地检查就形同虚设。</p>
<p>可能有同学会嘀咕，在 IDE 里面配置各种检查难道还不够么？对个人开发者来说足够了，但对于团队，如果对代码里面的坏味道听之任之，久而久之整个团队的代码质量标准都会被拉低，到最后坑的还是团队的每个成员，不是么？之前没想到这层的同学建议去看看破窗理论。</p>
<p>那么增加 Git Hooks 的必要性聊清楚了，我们应该在 Git Hooks 里面做哪些事情呢？通常来说：检查编码规范，把低级错误趁早挖出来修好；运行测试，用自动化的方法做功能回归，测试本身就包含很多话题，且按下不表。</p>
<p>前端社区里有多种结合 npm script 和 git-hooks 的方案，比如 <a href="https://github.com/observing/pre-commit" target="_blank" rel="noopener">pre-commit</a>、<a href="https://github.com/typicode/husky" target="_blank" rel="noopener">husky</a>，相比较而言 husky 更好用，它支持更多的 Git Hooks 种类，再结合 <a href="https://github.com/okonet/lint-staged" target="_blank" rel="noopener">lint-staged</a> 试用就更溜。</p>
<p>接下来我们逐步给示例项目配置本地的 Git Hooks，而在钩子中运行的是已有的 npm script，比如 lint、test：</p>
<h3 id="1-安装项目依赖"><a href="#1-安装项目依赖" class="headerlink" title="1. 安装项目依赖"></a>1. 安装项目依赖</h3><p>使用如下命令安装 husky、lint-staged 到项目依赖中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i husky lint-staged -D</span><br><span class="line"># npm install husky lint-staged --save-dev</span><br><span class="line"># yarn add husky lint-staged -D</span><br></pre></td></tr></table></figure>
<p>husky 的基本工作原理可以稍作解释下，翻看 husky 的 <a href="https://github.com/typicode/husky/blob/master/package.json" target="_blank" rel="noopener">package.json</a>，注意其中的 scripts 声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;test&quot;: &quot;jest&quot;,</span><br><span class="line">  &quot;format&quot;: &quot;prettier --single-quote --no-semi --write **/*.js&quot;,</span><br><span class="line">  &quot;install&quot;: &quot;node ./bin/install.js&quot;,</span><br><span class="line">  &quot;uninstall&quot;: &quot;node ./bin/uninstall.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>这里面的 install 就是你在项目中安装 husky 时执行的脚本（所有的魔法都藏在在这里了，哈哈）。</p>
<p>然后再检查我们仓库的 <code>.git/hooks</code> 目录，会发现里面的钩子都被 husky 替换掉了，注意下图中三个红色框中的内容：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052956cce1a5c3?w=905&amp;h=519&amp;f=png&amp;s=93983" alt="img"></p>
<h3 id="2-添加-npm-script"><a href="#2-添加-npm-script" class="headerlink" title="2. 添加 npm script"></a>2. 添加 npm script</h3><p>接下来需要在 scripts 对象中增加 husky 能识别的 Git Hooks 脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   &quot;scripts&quot;: &#123;</span><br><span class="line">+    &quot;precommit&quot;: &quot;npm run lint&quot;,</span><br><span class="line">+    &quot;prepush&quot;: &quot;npm run test&quot;,</span><br><span class="line">     &quot;lint&quot;: &quot;npm-run-all --parallel lint:*&quot;,</span><br><span class="line">     &quot;lint:js&quot;: &quot;eslint *.js&quot;,</span><br></pre></td></tr></table></figure>
<p>这两个命令的作用是在代码提交前运行所有的代码检查 npm run lint；在代码 push 到远程之前，运行 lint 和自动化测试（<strong>言外之意，如果测试失败，push 就不会成功</strong>），虽然运行的是 npm run test，但是 lint 也配置在了 pretest 里面。</p>
<p>然后尝试提交代码：<code>git commit -am &#39;add husky hooks&#39;</code>，能看到 pre-commit 钩子已经生效：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052959456b87ca?w=586&amp;h=110&amp;f=png&amp;s=22843" alt="img"></p>
<h3 id="3-用-lint-staged-改进-pre-commit"><a href="#3-用-lint-staged-改进-pre-commit" class="headerlink" title="3. 用 lint-staged 改进 pre-commit"></a>3. 用 lint-staged 改进 pre-commit</h3><p>如上的配置乍看起来没有任何问题，但是在大型项目、遗留项目中接入过 lint 工作流的同学可能深有体会，每次提交代码会检查所有的代码，可能比较慢就不说了，接入初期 lint 工具可能会报告几百上千个错误，这时候估计大多数人内心是崩溃的，尤其是当你是新规范的推进者，遇到的阻力会增大好几倍，毕竟大多数人不愿意背别人的锅，坏笑。</p>
<p>好在，我们有 lint-staged 来环节这个问题，每个团队成员提交的时候，只检查当次改动的文件，具体改动如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   &quot;scripts&quot;: &#123;</span><br><span class="line">-    &quot;precommit&quot;: &quot;npm run lint&quot;,</span><br><span class="line">+    &quot;precommit&quot;: &quot;lint-staged&quot;,</span><br><span class="line">     &quot;prepush&quot;: &quot;npm run test&quot;,</span><br><span class="line">     &quot;lint&quot;: &quot;npm-run-all --parallel lint:*&quot;,</span><br><span class="line">   &#125;,</span><br><span class="line">+  &quot;lint-staged&quot;: &#123;</span><br><span class="line">+    &quot;*.js&quot;: &quot;eslint&quot;,</span><br><span class="line">+    &quot;*.less&quot;: &quot;stylelint&quot;,</span><br><span class="line">+    &quot;*.css&quot;: &quot;stylelint&quot;,</span><br><span class="line">+    &quot;*.json&quot;: &quot;jsonlint --quiet&quot;,</span><br><span class="line">+    &quot;*.md&quot;: &quot;markdownlint --config .markdownlint.json&quot;</span><br><span class="line">+  &#125;,</span><br><span class="line">   &quot;keywords&quot;: [],</span><br></pre></td></tr></table></figure>
<p>接下来我们故意在 index.js 中引入错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-  return NaN;</span><br><span class="line">+  return NaN</span><br></pre></td></tr></table></figure>
<p>然后尝试提交这个文件：<code>git commit -m &#39;try to add eslint error&#39; index.js</code>，结果如下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/14/1605295bb21f26aa?w=733&amp;h=503&amp;f=png&amp;s=90551" alt="img"></p>
<p>上图中带有 <code>Running Tasks</code> 字样的列表就是 lint-staged 根据当前要提交的文件和 package.json 中配置的检查命令去执行的动态输出。红色框里面提示 husky 的 pre-commit 钩子执行失败，提交也就没有成功。</p>
<p>关于 lint-staged 还有些高级的用法，比如对单个文件执行多条命令，对单个文件动态自动修复，自动格式化等等，留待大家自己去探索好了。</p>
<p>撤销掉有错误的修改，提交之后，我们往远程 push 新分支，结果如下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052e6c6cba85ff?w=867&amp;h=460&amp;f=png&amp;s=160857" alt="img"></p>
<blockquote>
<p>读过我其他文章的同学可能已经想到，本小节的内容部分和我早期的文章<a href="https://juejin.im/post/592615580ce463006bf19aa0" target="_blank" rel="noopener">《用 husky 和 lint-staged 构建超溜的代码检查工作流》</a>有部分内容是重叠的。</p>
</blockquote>
<hr>
<blockquote>
<p>本节用到的代码见 <a href="https://github.com/wangshijun/automated-workflow-with-npm-script/tree/11-run-npm-script-in-git-hooks" target="_blank" rel="noopener">GitHub</a>，想边看边动手练习的同学可以拉下来自己改（<strong>记得安装 npm 依赖之后再运行脚本</strong>），注意切换到正确的分支 <code>11-run-npm-script-in-git-hooks</code>。</p>
</blockquote>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/用 npm script 打造超溜的前端工作流/实战篇 02：结合 live-reload 实现自动刷新/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵小金">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵小金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/17/用 npm script 打造超溜的前端工作流/实战篇 02：结合 live-reload 实现自动刷新/" itemprop="url">4.2 使用 livereload 实现自动刷新</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-17T11:11:39+08:00">
                2020-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/npm-script/" itemprop="url" rel="index">
                    <span itemprop="name">npm script</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="4-2-使用-livereload-实现自动刷新"><a href="#4-2-使用-livereload-实现自动刷新" class="headerlink" title="4.2 使用 livereload 实现自动刷新"></a>4.2 使用 livereload 实现自动刷新</h1><p>前端工程师日常开发最频繁（实际上最浪费时间）的操作是什么？可能你已经想到了，就是刷新页面，要让变更生效，需要重新加载，刷新页面的操作就变成了重复低效的操作。</p>
<p>于是社区里出现了 <a href="https://www.npmjs.com/package/livereload" target="_blank" rel="noopener">LiveReload</a> 来把这个过程自动化，react 种子项目生成工具 <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">create-react-app</a> 中就使用了这种技术。</p>
<p>但随着技术的演化，在单页应用中刷新页面意味着客户端状态的全部丢失，特别是复杂的单页应用刷新意味着更大量的重复工作才能回到刷新前的状态，于是社区又捣鼓出了 <a href="https://webpack.js.org/concepts/hot-module-replacement/" target="_blank" rel="noopener">Hot Module Replacement，简称为 HMR</a>，比如使用 <a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener">vue-cli</a> 创建的 <a href="https://github.com/vuejs-templates/webpack" target="_blank" rel="noopener">webpack</a> 种子项目中就包含这种特性，<a href="https://facebook.github.io/react-native/blog/2016/03/24/introducing-hot-reloading.html" target="_blank" rel="noopener">react-native</a> 也内置了这种特性，来帮助开发者提高效率。</p>
<p>读到这里，你可能会嘀咕，看起来 LiveReload 并不是最新的技术，还讨论它干啥，实际上它是自动刷新技术的鼻祖，后续的 HMR、HR 等都是它的改良版，动手配置下自动刷新，也能让你对这些技术的基本原理略知一二。</p>
<p>下面介绍如何在经典的前端项目中（引用了 css、js 的 html 页面）接入 LiveReload 的详细步骤：</p>
<h3 id="1-安装项目依赖"><a href="#1-安装项目依赖" class="headerlink" title="1. 安装项目依赖"></a>1. 安装项目依赖</h3><p>使用如下命令安装 <a href="https://www.npmjs.com/package/livereload" target="_blank" rel="noopener">livereload</a> 和 <a href="https://www.npmjs.com/package/http-server" target="_blank" rel="noopener">http-server</a> 到项目依赖中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i livereload http-server -D</span><br><span class="line"># npm install livereload http-server --save-dev</span><br><span class="line"># yarn add livereload http-server -D</span><br></pre></td></tr></table></figure>
<h3 id="2-添加-npm-script"><a href="#2-添加-npm-script" class="headerlink" title="2. 添加 npm script"></a>2. 添加 npm script</h3><p>按如下提示添加命令，方便我们启动 LiveReload 服务器和通过 HTTP 的方式访问页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-    &quot;cover:open&quot;: &quot;scripty&quot;</span><br><span class="line">+    &quot;cover:open&quot;: &quot;scripty&quot;,</span><br><span class="line">+    &quot;client&quot;: &quot;npm-run-all --parallel client:*&quot;,</span><br><span class="line">+    &quot;client:reload-server&quot;: &quot;livereload client/&quot;,</span><br><span class="line">+    &quot;client:static-server&quot;: &quot;http-server client/&quot;</span><br></pre></td></tr></table></figure>
<p>其中 client 命令能同时启动 livereload 服务、静态文件服务。</p>
<blockquote>
<p><strong>TIP#16</strong>：可能有同学会问，为什么需要启动两个服务，其中 http-server 启动的是静态文件服务器，该服务启动后可以通过 http 的方式访问文件系统上的文件，而 livereload 是启动了自动刷新服务，该服务负责监听文件系统变化，并在文件系统变化时通知所有连接的客户端，在 <code>client/index.html</code> 中嵌入的那段 js 实际上是和 livereload-server 连接的一个 livereload-client。</p>
</blockquote>
<h3 id="3-在页面中嵌入-livereload-脚本"><a href="#3-在页面中嵌入-livereload-脚本" class="headerlink" title="3. 在页面中嵌入 livereload 脚本"></a>3. 在页面中嵌入 livereload 脚本</h3><p>修改 client/index.html 嵌入 livereload 脚本（能够连接我们的 livereload 服务），diff 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;body&gt;</span><br><span class="line">   &lt;h2&gt;LiveReload Demo&lt;/h2&gt;</span><br><span class="line">+  &lt;script&gt;</span><br><span class="line">+    document.write(&apos;&lt;script src=&quot;http://&apos; + (location.host || &apos;localhost&apos;).split(&apos;:&apos;)[0] +</span><br><span class="line">+      &apos;:35729/livereload.js?snipver=1&quot;&gt;&lt;/&apos; + &apos;script&gt;&apos;)</span><br><span class="line">+  &lt;/script&gt;</span><br><span class="line"> &lt;/body&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>TIP#17</strong>：livereload 是支持在启动时自定义端口的，如果你使用了自定义端口，在页面中嵌入的这段 js 里面的 <code>35729</code> 也需要替换成对应的端口。</p>
</blockquote>
<h3 id="4-启动服务并测试"><a href="#4-启动服务并测试" class="headerlink" title="4. 启动服务并测试"></a>4. 启动服务并测试</h3><p>最后，运行 npm run client 之后，截图如下，注意两个红框里面的输出表示服务启动成功：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/14/1605294cbbf843bc?w=1066&amp;h=503&amp;f=png&amp;s=111997" alt="img"></p>
<p>然后，打开浏览器访问：<a href="http://localhost:8080，接着修改" target="_blank" rel="noopener">http://localhost:8080，接着修改</a> client/main.css 并保存（<strong>别忘了保存</strong>），你会发现浏览器自动刷新了。如果没有刷新，欢迎留言交流。</p>
<blockquote>
<p><strong>TIP#18</strong>：有代码洁癖的同学可能会问，在页面中嵌入的那段 js 在线上环境咋办？实际上在嵌入这段脚本的时候可以通过简单的手段（比如判断 location.hostname）去检查当前页面运行环境，如果是线上环境就不嵌入了，或者使用打包工具处理 html 文件，上线前直接去掉即可。</p>
</blockquote>
<hr>
<blockquote>
<p>本节用到的代码见 <a href="https://github.com/wangshijun/automated-workflow-with-npm-script/tree/10-livereload-with-npm-script" target="_blank" rel="noopener">GitHub</a>，想边看边动手练习的同学可以拉下来自己改，注意切换到正确的分支 <code>10-livereload-with-npm-script</code>。</p>
</blockquote>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/用 npm script 打造超溜的前端工作流/实战篇 01：监听文件变化并自动运行 npm script/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵小金">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵小金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/17/用 npm script 打造超溜的前端工作流/实战篇 01：监听文件变化并自动运行 npm script/" itemprop="url">4.1 文件变化时自动运行 npm script</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-17T11:11:38+08:00">
                2020-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/npm-script/" itemprop="url" rel="index">
                    <span itemprop="name">npm script</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="4-1-文件变化时自动运行-npm-script"><a href="#4-1-文件变化时自动运行-npm-script" class="headerlink" title="4.1 文件变化时自动运行 npm script"></a>4.1 文件变化时自动运行 npm script</h1><p>软件工程师做的事情基本都是在实现自动化，比如各种业务系统是为了业务运转的自动化，部署系统是为了运维的自动化，对于开发者本身，自动化也是提升效率的关键环节，在实际开发过程中也有不少事情是可以自动化的。</p>
<p>拥抱现代前端工作流的同学都会有代码风格检查、单元测试等环节，这样就很需要在代码变更之后立即得到反馈，如代码改动导致了那个 Case 失败，哪块不符合团队的编码规范等。</p>
<p>使用 gulp、grunt 的同学，可能对这种功能非常熟悉，不就是 watch 么？确实是，使用 npm script 我们也可以实现类似的功能。下面详细介绍如何改造我们的项目实现单测、代码检查的自动化。</p>
<h2 id="单元测试自动化"><a href="#单元测试自动化" class="headerlink" title="单元测试自动化"></a>单元测试自动化</h2><p>幸运的是，mocha 本身支持 <code>--watch</code> 参数，即在代码变化时自动重跑所有的测试，我们只需要在 scripts 对象中新增一条命令即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     &quot;test&quot;: &quot;cross-env NODE_ENV=test mocha tests/&quot;,</span><br><span class="line">+    &quot;watch:test&quot;: &quot;npm t -- --watch&quot;,</span><br><span class="line">     &quot;cover&quot;: &quot;node scripts/cover.js&quot;,</span><br></pre></td></tr></table></figure>
<p>尝试运行 npm run watch:test，我们会发现进程并没有退出，接下来尝试去修改测试代码，测试是不是自动重跑了呢？自己试试看。</p>
<h2 id="代码检查自动化"><a href="#代码检查自动化" class="headerlink" title="代码检查自动化"></a>代码检查自动化</h2><p>我们使用的代码检查工具 <a href="https://stylelint.io" target="_blank" rel="noopener">stylelint</a>、<a href="https://eslint.org" target="_blank" rel="noopener">eslint</a>、<a href="https://github.com/zaach/jsonlint" target="_blank" rel="noopener">jsonlint</a> 不全支持 watch 模式，这里我们需要借助 <a href="https://github.com/Qard/onchange" target="_blank" rel="noopener">onchange</a> 工具包来实现，onchange 可以方便的让我们在文件被修改、添加、删除时运行需要的命令。</p>
<h3 id="1-安装项目依赖"><a href="#1-安装项目依赖" class="headerlink" title="1. 安装项目依赖"></a>1. 安装项目依赖</h3><p>使用如下命令安装 onchange 到项目依赖中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i onchange -D</span><br><span class="line"># npm install onchange --save-dev</span><br><span class="line"># yarn add onchange -D</span><br></pre></td></tr></table></figure>
<h3 id="2-添加-npm-script"><a href="#2-添加-npm-script" class="headerlink" title="2. 添加 npm script"></a>2. 添加 npm script</h3><p>按照如下提示添加 watch:lint 和 watch 两个子命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+    &quot;watch&quot;: &quot;npm-run-all --parallel watch:*&quot;,</span><br><span class="line">+    &quot;watch:lint&quot;: &quot;onchange -i \&quot;**/*.js\&quot; \&quot;**/*.less\&quot; -- npm run lint&quot;,</span><br><span class="line">     &quot;watch:test&quot;: &quot;npm t -- --watch&quot;,</span><br></pre></td></tr></table></figure>
<p>关于改动的几点说明：</p>
<ul>
<li><code>watch:lint</code> 里面的文件匹配模式可以使用通配符，但是模式两边使用了转义的双引号，这样是跨平台兼容的；</li>
<li><code>watch:lint</code> 里面的 <code>-i</code> 参数是让 onchange 在启动时就运行一次 <code>--</code> 之后的命令，即代码没变化的时候，变化前后的对比大多数时候还是有价值的；</li>
<li>watch 命令实际上是使用了 npm-run-all 来运行所有的 watch 子命令；</li>
</ul>
<blockquote>
<p><strong>TIP#15</strong>：有没有好奇过 onchange 是怎么实现文件系统监听的？所有的魔法都藏在它的源代码里面，实际上它使用了跨平台的文件系统监听包 <a href="https://github.com/paulmillr/chokidar" target="_blank" rel="noopener">chokidar</a>，基于它，你能做点什么有意思的事情呢？</p>
</blockquote>
<p>onchange 有个不太醒目的特性是，文件系统发生变化之后，他在运行指定命令之前输出哪个文件发生了哪些变化，如下图红框中的内容：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/12/160481d04f4e2aa5?w=951&amp;h=533&amp;f=png&amp;s=77037" alt="img"></p>
<p>读到这里，有没有觉得 onchange 可以和 gulp、grunt 的 watch 一样强大。</p>
<blockquote>
<p>除了上面的单测重跑和代码检查之外，你还有什么需求需要放在 onchange 里面？欢迎留言讨论。</p>
</blockquote>
<hr>
<blockquote>
<p>本节用到的代码见 <a href="https://github.com/wangshijun/automated-workflow-with-npm-script/tree/09-run-npm-script-with-onchange" target="_blank" rel="noopener">GitHub</a>，想边看边动手练习的同学可以拉下来自己改，注意切换到正确的分支 <code>09-run-npm-script-with-onchange</code>。</p>
</blockquote>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/用 npm script 打造超溜的前端工作流/高阶篇 03：用 node.js 脚本替代复杂的 npm script/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵小金">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵小金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/17/用 npm script 打造超溜的前端工作流/高阶篇 03：用 node.js 脚本替代复杂的 npm script/" itemprop="url">3.3 用 node.js 脚本替代复杂的 npm script</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-17T11:11:37+08:00">
                2020-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/npm-script/" itemprop="url" rel="index">
                    <span itemprop="name">npm script</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="3-3-用-node-js-脚本替代复杂的-npm-script"><a href="#3-3-用-node-js-脚本替代复杂的-npm-script" class="headerlink" title="3.3 用 node.js 脚本替代复杂的 npm script"></a>3.3 用 node.js 脚本替代复杂的 npm script</h1><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a> 丰富的生态能赋予我们更强的能力，对于前端工程师来说，使用 Node.js 来编写复杂的 npm script 具有明显的 2 个优势：首先，编写简单的工具脚本对前端工程师来说额外的学习成本很低甚至可以忽略不计，其次，因为 Node.js 本身是跨平台的，用它编写的脚本出现跨平台兼容问题的概率很小。</p>
<p>下面我们就一起探索下，如何把上节中使用 shell 编写的 cover 脚本改写成 Node.js 脚本，在 Node.js 脚本中我们也能体味到 <a href="https://www.npmjs.com/package/shelljs" target="_blank" rel="noopener">shelljs</a> 这个工具包的强大。</p>
<h3 id="1-安装-shelljs-依赖"><a href="#1-安装-shelljs-依赖" class="headerlink" title="1. 安装 shelljs 依赖"></a>1. 安装 shelljs 依赖</h3><p>使用如下命令安装 shelljs 到项目依赖中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i shelljs -D</span><br><span class="line"># npm install shelljs --save-dev</span><br><span class="line"># yarn add shelljs -D</span><br></pre></td></tr></table></figure>
<p>此外，我们计划使用 <a href="https://www.npmjs.com/package/chalk" target="_blank" rel="noopener">chalk</a> 来给输出加点颜色，让脚本变的更有趣，同样安装到 devDependencies 里面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i chalk -D</span><br><span class="line"># npm install chalk --save-dev</span><br><span class="line"># yarn add chalk -D</span><br></pre></td></tr></table></figure>
<h3 id="2-创建-Node-js-脚本"><a href="#2-创建-Node-js-脚本" class="headerlink" title="2. 创建 Node.js 脚本"></a>2. 创建 Node.js 脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch scripts/cover.js</span><br></pre></td></tr></table></figure>
<h3 id="3-用-Node-js-实现同等功能"><a href="#3-用-Node-js-实现同等功能" class="headerlink" title="3. 用 Node.js 实现同等功能"></a>3. 用 Node.js 实现同等功能</h3><p>shelljs 为我们提供了各种常见命令的跨平台支持，比如 cp、mkdir、rm、cd 等命令，此外，理论上你可以在 Node.js 脚本中使用任何 <a href="https://www.npmjs.com" target="_blank" rel="noopener">npmjs.com</a> 上能找到的包。清理归档目录、运行测试、归档并预览覆盖率报告的完整 Node.js 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const &#123; rm, cp, mkdir, exec, echo &#125; = require(&apos;shelljs&apos;);</span><br><span class="line">const chalk = require(&apos;chalk&apos;);</span><br><span class="line"></span><br><span class="line">console.log(chalk.green(&apos;1. remove old coverage reports...&apos;));</span><br><span class="line">rm(&apos;-rf&apos;, &apos;coverage&apos;);</span><br><span class="line">rm(&apos;-rf&apos;, &apos;.nyc_output&apos;);</span><br><span class="line"></span><br><span class="line">console.log(chalk.green(&apos;2. run test and collect new coverage...&apos;));</span><br><span class="line">exec(&apos;nyc --reporter=html npm run test&apos;);</span><br><span class="line"></span><br><span class="line">console.log(chalk.green(&apos;3. archive coverage report by version...&apos;));</span><br><span class="line">mkdir(&apos;-p&apos;, &apos;coverage_archive/$npm_package_version&apos;);</span><br><span class="line">cp(&apos;-r&apos;, &apos;coverage/*&apos;, &apos;coverage_archive/$npm_package_version&apos;);</span><br><span class="line"></span><br><span class="line">console.log(chalk.green(&apos;4. open coverage report for preview...&apos;));</span><br><span class="line">exec(&apos;npm-run-all --parallel cover:serve cover:open&apos;);</span><br></pre></td></tr></table></figure>
<p>关于改动的几点说明：</p>
<ul>
<li>简单的文件系统操作，建议直接使用 shelljs 提供的 cp、rm 等替换；</li>
<li>部分稍复杂的命令，比如 nyc 可以使用 exec 来执行，也可以使用 istanbul 包来完成；</li>
<li>在 exec 中也可以大胆的使用 npm script 运行时的环境变量，比如 <code>$npm_package_version</code>；</li>
</ul>
<h3 id="4-让-package-json-指向新脚本"><a href="#4-让-package-json-指向新脚本" class="headerlink" title="4. 让 package.json 指向新脚本"></a>4. 让 package.json 指向新脚本</h3><p>准备好 Node.js 脚本之后，我们需要修改 package.json 里面的命令，使其运行该脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   &quot;scripts&quot;: &#123;</span><br><span class="line">     &quot;test&quot;: &quot;cross-env NODE_ENV=test mocha tests/&quot;,</span><br><span class="line">-    &quot;cover&quot;: &quot;scripty&quot;,</span><br><span class="line">+    &quot;cover&quot;: &quot;node scripts/cover.js&quot;,</span><br><span class="line">     &quot;cover:open&quot;: &quot;scripty&quot;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>
<h3 id="5-测试-cover-命名"><a href="#5-测试-cover-命名" class="headerlink" title="5. 测试 cover 命名"></a>5. 测试 cover 命名</h3><p>重新运行 npm run cover 命令，不出意外的话，基本功能是正常的，除了我们新加的绿色输出，如下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603de95af9b2c41?w=1060&amp;h=587&amp;f=png&amp;s=87226" alt="img"></p>
<p>以上，本小节完，这里只是简单展示了如何组织 Node.js 脚本并且让其与 npm script 关联起来，至于具体在脚本中做什么事情，请你自由发挥吧。</p>
<hr>
<blockquote>
<p>本节用到的代码见 <a href="https://github.com/wangshijun/automated-workflow-with-npm-script/tree/08-using-nodejs-script-as-replacement" target="_blank" rel="noopener">GitHub</a>，想边看边动手练习的同学可以拉下来自己改，注意切换到正确的分支 <code>08-using-nodejs-script-as-replacement</code>。</p>
</blockquote>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/用 npm script 打造超溜的前端工作流/高阶篇 02：把庞大的 npm script 拆到单独文件中/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵小金">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵小金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/17/用 npm script 打造超溜的前端工作流/高阶篇 02：把庞大的 npm script 拆到单独文件中/" itemprop="url">3.2 把庞大的 npm script 拆到单独文件中</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-17T11:11:36+08:00">
                2020-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/npm-script/" itemprop="url" rel="index">
                    <span itemprop="name">npm script</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="3-2-把庞大的-npm-script-拆到单独文件中"><a href="#3-2-把庞大的-npm-script-拆到单独文件中" class="headerlink" title="3.2 把庞大的 npm script 拆到单独文件中"></a>3.2 把庞大的 npm script 拆到单独文件中</h1><p>当 npm script 不断累积、膨胀的时候，全部放在 package.json 里面可能并不是个好主意，因为这样会导致 package.json 糟乱，可读性降低。</p>
<p>借助 <a href="https://github.com/testdouble/scripty" target="_blank" rel="noopener">scripty</a> 我们可以将 npm script 剥离到单独的文件中，从而把复杂性隔到单独的模块里面，让代码整体看起来更加清晰。</p>
<p>示例项目中的覆盖率相关的 npm script 占据了很大的篇幅，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;cover&quot;: &quot;nyc --reporter=html npm test&quot;,</span><br><span class="line">  &quot;cover:cleanup&quot;: &quot;rimraf coverage &amp;&amp; rimraf .nyc_output&quot;,</span><br><span class="line">  &quot;cover:archive&quot;: &quot;cross-var \&quot;make-dir coverage_archive/$npm_package_version &amp;&amp; cpr coverage/* coverage_archive/$npm_package_version -o\&quot;&quot;,</span><br><span class="line">  &quot;cover:serve&quot;: &quot;cross-var http-server coverage_archive/$npm_package_version -p $npm_package_config_port&quot;,</span><br><span class="line">  &quot;cover:open&quot;: &quot;cross-var opn http://localhost:$npm_package_config_port&quot;,</span><br><span class="line">  &quot;precover&quot;: &quot;npm run cover:cleanup&quot;,</span><br><span class="line">  &quot;postcover&quot;: &quot;npm-run-all cover:archive --parallel cover:serve cover:open&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>如果要隔离复杂性，我们可以考虑从 cover 相关的 script 入手，具体操作步骤如下：</p>
<h3 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i scripty -D</span><br><span class="line"># npm install scripty --save-dev</span><br><span class="line"># yarn add scripty -D</span><br></pre></td></tr></table></figure>
<h3 id="2-准备目录和文件"><a href="#2-准备目录和文件" class="headerlink" title="2. 准备目录和文件"></a>2. 准备目录和文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p scripts/cover</span><br></pre></td></tr></table></figure>
<p>先创建两层的目录，因为我们计划把 cover 脚本写成多个，方便单独去执行，这里命名为 scripts 是 scripty 默认的，实际上是可以自定义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch scripts/cover.sh</span><br><span class="line">touch scripts/cover/serve.sh</span><br><span class="line">touch scripts/cover/open.sh</span><br></pre></td></tr></table></figure>
<p>然后创建空白的脚本文件，因为有了单独的脚本，我们可以把原来的 precover、cover、postcover、cover:archive、cover:cleanup 合并到一个文件中。</p>
<p>按照 scripty 的默认约定，npm script 命令和上面各文件的对应关系如下：</p>
<p>命令</p>
<p>文件</p>
<p>备注</p>
<p>cover</p>
<p>scripts/cover.sh</p>
<p>内含 precover、postcover 的逻辑</p>
<p>cover:serve</p>
<p>scripts/cover/serve.sh</p>
<p>启动服务</p>
<p>cover:open</p>
<p>scripts/cover/open.sh</p>
<p>打开预览</p>
<p><strong>特别注意的是，给所有脚本增加可执行权限是必须的，否则 scripty 执行时会报错</strong>，我们可以给所有的脚本增加可执行权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R a+x scripts/**/*.sh</span><br></pre></td></tr></table></figure>
<h3 id="3-修改-scripty-脚本"><a href="#3-修改-scripty-脚本" class="headerlink" title="3. 修改 scripty 脚本"></a>3. 修改 scripty 脚本</h3><p>准备好目录和文件之后，接下来需要给脚本填充内容，脚本内容如下（因为脚本使用的是 bash，所以直接忽略了跨平台兼容的处理，跨平台兼容脚本最好使用 Node.js 编写，下节会介绍）：</p>
<p><code>scripts/cover.sh</code> 内容如下（cleanup –&gt; cover –&gt; archive –&gt; preview）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line"># remove old coverage reports</span><br><span class="line">rimraf coverage &amp;&amp; rimraf .nyc_output</span><br><span class="line"></span><br><span class="line"># run test and collect new coverage</span><br><span class="line">nyc --reporter=html npm run test</span><br><span class="line"></span><br><span class="line"># achive coverage report by version</span><br><span class="line">mkdir -p coverage_archive/$npm_package_version</span><br><span class="line">cp -r coverage/* coverage_archive/$npm_package_version</span><br><span class="line"></span><br><span class="line"># open coverage report for preview</span><br><span class="line">npm-run-all --parallel cover:serve cover:open</span><br></pre></td></tr></table></figure>
<p><code>scripts/cover/serve.sh</code> 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line">http-server coverage_archive/$npm_package_version -p $npm_package_config_port</span><br></pre></td></tr></table></figure>
<p><code>scripts/cover/open.sh</code> 内容如下（这里有个 sleep，是为了确保文件系统写入完成）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line">opn http://localhost:$npm_package_config_port</span><br></pre></td></tr></table></figure>
<p>细心的同学可能注意到了，在 shell 脚本里面是可以随意使用 npm 的内置变量和自定义变量的。</p>
<h3 id="4-修改-package-json"><a href="#4-修改-package-json" class="headerlink" title="4. 修改 package.json"></a>4. 修改 package.json</h3><p>主要改动是清理 cover:* 命令，接入 scripty，具体的 diff 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   &quot;scripts&quot;: &#123;</span><br><span class="line">     &quot;test&quot;: &quot;cross-env NODE_ENV=test mocha tests/&quot;,</span><br><span class="line">-    &quot;cover&quot;: &quot;nyc --reporter=html npm test&quot;,</span><br><span class="line">-    &quot;cover:cleanup&quot;: &quot;rimraf coverage &amp;&amp; rimraf .nyc_output&quot;,</span><br><span class="line">-    &quot;cover:archive&quot;: &quot;cross-var \&quot;make-dir coverage_archive/$npm_package_version &amp;&amp; cpr coverage/* coverage_archive/$npm_package_version -o\&quot;&quot;,</span><br><span class="line">-    &quot;cover:serve&quot;: &quot;cross-var http-server coverage_archive/$npm_package_version -p $npm_package_config_port&quot;,</span><br><span class="line">-    &quot;cover:open&quot;: &quot;cross-var opn http://localhost:$npm_package_config_port&quot;,</span><br><span class="line">-    &quot;precover&quot;: &quot;npm run cover:cleanup&quot;,</span><br><span class="line">-    &quot;postcover&quot;: &quot;npm-run-all cover:archive --parallel cover:serve cover:open&quot;</span><br><span class="line">+    &quot;cover&quot;: &quot;scripty&quot;,</span><br><span class="line">+    &quot;cover:serve&quot;: &quot;scripty&quot;,</span><br><span class="line">+    &quot;cover:open&quot;: &quot;scripty&quot;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>
<p>这里我们只保留了 cover、cover:serve、cover:open 等 3 个命令，让它们都指向 scripty，调用哪个脚本都由 scripty 来处理。</p>
<h3 id="5-实际测试"><a href="#5-实际测试" class="headerlink" title="5. 实际测试"></a>5. 实际测试</h3><p>修改完毕之后，重新运行 npm run cover，不出意外的话，我们能得到和原来完全相同的结果，仔细观察运行的日志，会发现在代码执行前有段额外的输出，如下图中红色框中的内容，scripty 在实际执行的时候会把执行的命令内容打印出来，方便调试：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/7/1602e70a1b4df91b?w=874&amp;h=711&amp;f=png&amp;s=94680" alt="img"></p>
<h3 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h3><p>scripty 比上面演示的要更强大，也支持通配符运行、脚本并行等特性、静默模式，如果有需求可以阅读官方的 <a href="https://github.com/testdouble/scripty#advanced-usage" target="_blank" rel="noopener">README.md</a>，毕竟咱们已经入门了，不是么？</p>
<hr>
<blockquote>
<p>本节用到的代码见 <a href="https://github.com/wangshijun/automated-workflow-with-npm-script/tree/07-manage-complexity-using-scripty" target="_blank" rel="noopener">GitHub</a>，想边看边动手练习的同学可以拉下来自己改，注意切换到正确的分支 <code>07-manage-complexity-using-scripty</code>。</p>
</blockquote>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/用 npm script 打造超溜的前端工作流/高阶篇 01：实现 npm script 跨平台兼容/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵小金">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵小金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/17/用 npm script 打造超溜的前端工作流/高阶篇 01：实现 npm script 跨平台兼容/" itemprop="url">3.1 实现 npm script 跨平台兼容</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-17T11:11:35+08:00">
                2020-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/npm-script/" itemprop="url" rel="index">
                    <span itemprop="name">npm script</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="3-1-实现-npm-script-跨平台兼容"><a href="#3-1-实现-npm-script-跨平台兼容" class="headerlink" title="3.1 实现 npm script 跨平台兼容"></a>3.1 实现 npm script 跨平台兼容</h1><p>到目前为止，如果你在 Linux、Mac 平台做开发，所有的 npm script 都会顺利运行，但是 Windows 下面的同学可能就比较痛苦了，因为不是所有的 shell 命令都是跨平台兼容的，甚至各种常见的文件系统操作也是不兼容的。</p>
<p>可能有部分同学处理过 npm script 跨平台兼容的问题，比如粗暴的为两种平台各写一份 npm script，像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hello-npm-script&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;bash-script&quot;: &quot;echo Hello $npm_package_name&quot;,</span><br><span class="line">    &quot;win-script&quot;: &quot;echo Hello %npm_package_name%&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有技术追求的工程师肯定不会满足上面的解决方案，实际上社区中已经有非常多的小工具可以帮我们优雅的实现跨平台的 npm script，下面我们探索下如何实现跨平台的文件系统操作、变量引用、环境变量设置。</p>
<p><strong>特别说明，windows 环境的同学建议使用 git bash 来运行 npm script，使用 windows 自带的 cmd 可能会遇到比较多的问题</strong></p>
<h2 id="文件系统操作的跨平台兼容"><a href="#文件系统操作的跨平台兼容" class="headerlink" title="文件系统操作的跨平台兼容"></a>文件系统操作的跨平台兼容</h2><p>npm script 中涉及到的文件系统操作包括文件和目录的创建、删除、移动、复制等操作，而社区为这些基本操作也提供了跨平台兼容的包，列举如下：</p>
<ul>
<li><a href="https://github.com/isaacs/rimraf" target="_blank" rel="noopener">rimraf</a> 或 <a href="https://www.npmjs.com/package/del-cli" target="_blank" rel="noopener">del-cli</a>，用来删除文件和目录，实现类似于 <code>rm -rf</code> 的功能；</li>
<li><a href="https://www.npmjs.com/package/cpr" target="_blank" rel="noopener">cpr</a>，用于拷贝、复制文件和目录，实现类似于 <code>cp -r</code> 的功能；</li>
<li><a href="https://www.npmjs.com/package/make-dir-cli" target="_blank" rel="noopener">make-dir-cli</a>，用于创建目录，实现类似于 <code>mkdir -p</code> 的功能；</li>
</ul>
<p>使用上面这几个小工具改造 npm script 的具体步骤如下：</p>
<p>第 1 步，添加开发依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i rimraf cpr make-dir-cli -D</span><br><span class="line"># npm install rimraf cpr make-dir-cli --save-dev</span><br><span class="line"># yarn add rimraf cpr make-dir-cli -D</span><br></pre></td></tr></table></figure>
<p>第 2 步，改造涉及文件系统操作的 npm script：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">-    &quot;cover:cleanup&quot;: &quot;rm -rf coverage &amp;&amp; rm -rf .nyc_output&quot;,</span><br><span class="line">-    &quot;cover:archive&quot;: &quot;cross-var \&quot;mkdir -p coverage_archive/$npm_package_version &amp;&amp; cp -r coverage/* coverage_archive/$npm_package_version\&quot;&quot;,</span><br><span class="line">+    &quot;cover:cleanup&quot;: &quot;rimraf coverage &amp;&amp; rimraf .nyc_output&quot;,</span><br><span class="line">+    &quot;cover:archive&quot;: &quot;cross-var \&quot;make-dir coverage_archive/$npm_package_version &amp;&amp; cpr coverage/* coverage_archive/$npm_package_version -o\&quot;&quot;,</span><br><span class="line">     &quot;cover:serve&quot;: &quot;cross-var http-server coverage_archive/$npm_package_version -p $npm_package_config_port&quot;,</span><br><span class="line">     &quot;cover:open&quot;: &quot;cross-var opn http://localhost:$npm_package_config_port&quot;,</span><br><span class="line">-    &quot;postcover&quot;: &quot;npm-run-all cover:archive cover:cleanup --parallel cover:serve cover:open&quot;</span><br><span class="line">+    &quot;precover&quot;: &quot;npm run cover:cleanup&quot;,</span><br><span class="line">+    &quot;postcover&quot;: &quot;npm-run-all cover:archive --parallel cover:serve cover:open&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>对改动的几点说明：</p>
<ul>
<li><code>rm -rf</code> 直接替换成 <code>rimraf</code>；</li>
<li><code>mkdir -p</code> 直接替换成 <code>make-dir</code>；</li>
<li><code>cp -r</code> 的替换需特别说明下，<code>cpr</code> 默认是不覆盖的，需要显示传入 <code>-o</code> 配置项，并且参数必须严格是 <code>cpr &lt;source&gt; &lt;destination&gt; [options]</code> 的格式，即配置项放在最后面；</li>
<li>把 <code>cover:cleanup</code> 从 <code>postcover</code> 挪到 <code>precover</code> 里面去执行，规避 <code>cpr</code> 没归档完毕覆盖率报告就被清空的问题；</li>
</ul>
<blockquote>
<p><strong>TIP#13</strong>：任何改动之后记得重新运行 npm run cover，确保所有的 npm script 还是按预期工作的</p>
</blockquote>
<h2 id="用-cross-var-引用变量"><a href="#用-cross-var-引用变量" class="headerlink" title="用 cross-var 引用变量"></a>用 cross-var 引用变量</h2><p><a href="https://juejin.im/book/5a1212bc51882531ea64df07/section/5a12146951882531bb6c68fe" target="_blank" rel="noopener">2.2 在 npm script 中使用变量</a> 介绍了如何使用内置和预定义变量减少代码重复的技巧，如本节开头的例子，Linux 和 Windows 下引用变量的方式是不同的，Linux 下直接可以用 <code>$npm_package_name</code>，而 Windows 下必须使用 <code>%npm_package_name%</code>，我们可以使用 <a href="https://www.npmjs.com/package/cross-var" target="_blank" rel="noopener">cross-var</a> 实现跨平台的变量引用，具体步骤如下：</p>
<p>第 1 步，安装 cross-var 为开发依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i cross-var -D</span><br><span class="line"># npm install cross-var --save-dev</span><br><span class="line"># yarn add cross-var -D</span><br></pre></td></tr></table></figure>
<p>第 2 步，改写引用变量 npm script，具体 diff 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">     &quot;cover:cleanup&quot;: &quot;rm -rf coverage &amp;&amp; rm -rf .nyc_output&quot;,</span><br><span class="line">-    &quot;cover:archive&quot;: &quot;mkdir -p coverage_archive/$npm_package_version &amp;&amp; cp -r coverage/* coverage_archive/$npm_package_version&quot;,</span><br><span class="line">-    &quot;cover:serve&quot;: &quot;http-server coverage_archive/$npm_package_version -p $npm_package_config_port&quot;,</span><br><span class="line">-    &quot;cover:open&quot;: &quot;opn http://localhost:$npm_package_config_port&quot;,</span><br><span class="line">+    &quot;cover:archive&quot;: &quot;cross-var \&quot;mkdir -p coverage_archive/$npm_package_version &amp;&amp; cp -r coverage/* coverage_archive/$npm_package_version\&quot;&quot;,</span><br><span class="line">+    &quot;cover:serve&quot;: &quot;cross-var http-server coverage_archive/$npm_package_version -p $npm_package_config_port&quot;,</span><br><span class="line">+    &quot;cover:open&quot;: &quot;cross-var opn http://localhost:$npm_package_config_port&quot;,</span><br><span class="line">     &quot;postcover&quot;: &quot;npm-run-all cover:archive cover:cleanup --parallel cover:serve cover:open&quot;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>
<p>因为 cover:serve 和 cover:open 命令都比较简单，直接在原始命令前增加 cross-var 命令即可，而 cover:archive 内含了两条子命令，我们需要用引号把整个命令包起来（注意这里是用的双引号，且必须转义），然后在前面加上 cross-var。</p>
<p>此外，细心的同学可能发现引入 cross-var 之后，它竟然给我们安装了 babel，如果想保持依赖更轻量的话，可以考虑使用 <a href="https://www.npmjs.com/package/cross-var-no-babel" target="_blank" rel="noopener">cross-var-no-babel</a>。</p>
<h2 id="用-cross-env-设置环境变量"><a href="#用-cross-env-设置环境变量" class="headerlink" title="用 cross-env 设置环境变量"></a>用 cross-env 设置环境变量</h2><p>在 node.js 脚本和 npm script 使用环境变量也是比较常见的，比如我们在运行测试时，需要加上 <code>NODE_ENV=test</code>，或者在启动静态资源服务器时自定义端口号。因为不同平台的环境变量语法不同，我们可以使用 <a href="https://www.npmjs.com/package/cross-env" target="_blank" rel="noopener">cross-env</a> 来实现 npm script 的跨平台兼容，具体步骤如下：</p>
<p>第 1 步，添加 cross-env 到开发依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i cross-env -D</span><br><span class="line"># npm install cross-env --save-dev</span><br><span class="line"># yarn add cross-env -D</span><br></pre></td></tr></table></figure>
<p>第 2 步，改写使用了环境变量的 npm script：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">-    &quot;test&quot;: &quot;NODE_ENV=test mocha tests/&quot;,</span><br><span class="line">+    &quot;test&quot;: &quot;cross-env NODE_ENV=test mocha tests/&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>上面的改动更简单，直接在设置了环境变量的命令前面加上 cross-env 即可。</p>
<h2 id="再多说几句"><a href="#再多说几句" class="headerlink" title="再多说几句"></a>再多说几句</h2><p>关于 npm script 的跨平台兼容，还有几点需要大家注意：</p>
<ul>
<li>所有使用引号的地方，建议使用双引号，并且加上转义；</li>
<li>没做特殊处理的命令比如 eslint、stylelint、mocha、opn 等工具本身都是跨平台兼容的；</li>
<li>还是强烈建议有能力的同学能使用 Linux 做开发，只要你入门并且熟练了，效率提升会惊人；</li>
<li>短时间内继续拥抱 Windows 的同学，可以考虑看看 Windows 10 里面引入的 <a href="https://msdn.microsoft.com/en-us/commandline/wsl/about" target="_blank" rel="noopener">Subsystem</a>，让你不用虚拟机即可在 Windows 下使用大多数 Linux 命令。</li>
</ul>
<blockquote>
<p><strong>TIP#14</strong>：如果你在编写 npm script 过程中有更多的跨平台兼容需求，基本思路是去 <a href="https://www.npmjs.com/search?q=cross%20platform" target="_blank" rel="noopener">npmjs.com</a> 上找对应的包，关键词自然少不了 <code>cross platform</code>，你遇到的问题，肯定很多其他人遇到过，相信我，你并不孤独！</p>
</blockquote>
<hr>
<blockquote>
<p>本节用到的代码见 <a href="https://github.com/wangshijun/automated-workflow-with-npm-script/tree/06-add-cross-platform-support" target="_blank" rel="noopener">GitHub</a>，想边看边动手练习的同学可以拉下来自己改，注意切换到正确的分支 <code>06-add-cross-platform-support</code>。</p>
</blockquote>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/用 npm script 打造超溜的前端工作流/进阶篇 03：实现 npm script 命令自动补全/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵小金">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵小金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/17/用 npm script 打造超溜的前端工作流/进阶篇 03：实现 npm script 命令自动补全/" itemprop="url">2.3 实现命令行自动补全</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-17T11:11:34+08:00">
                2020-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/npm-script/" itemprop="url" rel="index">
                    <span itemprop="name">npm script</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2-3-实现命令行自动补全"><a href="#2-3-实现命令行自动补全" class="headerlink" title="2.3 实现命令行自动补全"></a>2.3 实现命令行自动补全</h1><p>当 npm script 里面积累的命令越来越多时，重度命令行用户肯定会好奇，能不能实现类似 bash、zsh 里面的命令自动补全？答案是肯定的，下面来逐一介绍。</p>
<h2 id="使用-npm-run-直接列出"><a href="#使用-npm-run-直接列出" class="headerlink" title="使用 npm run 直接列出"></a>使用 npm run 直接列出</h2><p>前面章节有过介绍，不带任何参数运行 npm run 能列出 scripts 对象中定义的所有命令，再结合管道操作符、less 命令（这里的 less 不是 css 领域的 less，而是 linux 里面的工具），即使 scripts 子命令很多我们也能移动自如。</p>
<p>比如，我们在项目中执行：<code>npm run | less</code>，得到如下结果，注意截图左下方的红框，按空格能翻页：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601bcdae64f00ea?w=1094&amp;h=715&amp;f=png&amp;s=101307" alt="img"></p>
<p>在这个结果里面，我们可以进行类似于 Vim 中的搜索，先按 <code>/</code> 进入搜索模式，然后输入 <code>markdown</code>，搜索结果如下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601bcdd6b736441?w=1100&amp;h=399&amp;f=png&amp;s=59941" alt="img"></p>
<h2 id="把-npm-completion-集成到-shell-中"><a href="#把-npm-completion-集成到-shell-中" class="headerlink" title="把 npm completion 集成到 shell 中"></a>把 npm completion 集成到 shell 中</h2><p>npm 自身提供了自动完成工具 <a href="https://docs.npmjs.com/cli/completion" target="_blank" rel="noopener">completion</a>，将其集成到 <a href="https://www.gnu.org/software/bash" target="_blank" rel="noopener">bash</a> 或者 <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">zsh</a> 里也非常容易（顺便说一句，早期我是 bash 的忠实用户，两年前切换到 zsh，就再也没回头）。</p>
<p>官方文档里面的集成方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm completion &gt;&gt; ~/.bashrc</span><br><span class="line">npm completion &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>TIP#10</strong>：如果你好奇上面的命令究竟做了什么，尝试直接运行 <code>npm completion</code>，就能看到它其实在你的配置文件中追加了一大坨 shell。上面命令中的 <code>&gt;&gt;</code> 意思是把前面命令的输出追加到后面的文件中。</p>
</blockquote>
<p>如果你也有代码洁癖，为了保持 .zshrc 或者 .bashrc 文件的整洁，可以用下面的方法：</p>
<p>第 1 步，把 npm completion 产生的那坨命令放在单独的文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm completion &gt;&gt; ~/.npm-completion.bash</span><br></pre></td></tr></table></figure>
<p>第 2 步，在 .bashrc 或者 .zshrc 中引入这个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;[ -f ~/.npm-completion.bash ] &amp;&amp; source ~/.npm-completion.bash;&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">echo &quot;[ -f ~/.npm-completion.bash ] &amp;&amp; source ~/.npm-completion.bash;&quot; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>TIP#11</strong>：执行完上面的命令一定要记得 <code>source ~/.zshrc</code> 或者 <code>source ~/.bashrc</code>，来让自动完成生效。</p>
</blockquote>
<p>接下来我们就可以尽情享受自动完成带来的便利了，尝试在命令行中输入 npm run，<strong>然后键入空格（空格很重要）</strong>，然后键入 tab 键，发现命令行有什么反应了么？在列出备选项之后，继续按 tab，就能在不同的选项之间切换，找到自己想要的，直接回车就能完成命令补全。多练习几次，你的手指和大脑就能熟练掌握这个过程。</p>
<p>在我们的项目目录里面键入 <code>npm run cov</code> 再键入 tab 键，命令行又有什么反应？</p>
<p>需要单独说明的是，npm completion 能实现的自动完成不仅仅是 scripts 里面的子自命令，npm 的子命令也是可以的，可以依次输入 <code>npm</code>、空格、tab，看看命令行的反应。</p>
<h2 id="更高级的自动完成"><a href="#更高级的自动完成" class="headerlink" title="更高级的自动完成"></a>更高级的自动完成</h2><p>人类对于效率的追求是永无止境的，工程师更是如此，npm 命令补全到目前为止显然还不够高效，能不能补全 package.json 里面的依赖名称？能不能在补全 npm script 的时候列出这个命令是干啥的？</p>
<p>有人已经帮我们解决了这个痛点，还写成了 zsh 插件（bash 的同学无福消受了）：<a href="https://github.com/lukechilds/zsh-better-npm-completion" target="_blank" rel="noopener">zsh-better-npm-completion</a>，它有以下几个让人无法拒绝的便利：</p>
<h3 id="1-在-npm-install-时自动根据历史安装过的包给出补全建议"><a href="#1-在-npm-install-时自动根据历史安装过的包给出补全建议" class="headerlink" title="1. 在 npm install 时自动根据历史安装过的包给出补全建议"></a>1. 在 npm install 时自动根据历史安装过的包给出补全建议</h3><p><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601bce81ef5dac6?w=1267&amp;h=249&amp;f=png&amp;s=65352" alt="img"></p>
<h3 id="2-在-npm-uninstall-时候根据-package-json-里面的声明给出补全建议"><a href="#2-在-npm-uninstall-时候根据-package-json-里面的声明给出补全建议" class="headerlink" title="2. 在 npm uninstall 时候根据 package.json 里面的声明给出补全建议"></a>2. 在 npm uninstall 时候根据 package.json 里面的声明给出补全建议</h3><p><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601bcec1c11549f?w=1263&amp;h=114&amp;f=png&amp;s=26712" alt="img"></p>
<h3 id="3-在-npm-run-时补全建议中列出命令细节"><a href="#3-在-npm-run-时补全建议中列出命令细节" class="headerlink" title="3. 在 npm run 时补全建议中列出命令细节"></a>3. 在 npm run 时补全建议中列出命令细节</h3><p><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601bcf08dc06346?w=1256&amp;h=331&amp;f=png&amp;s=78999" alt="img"></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601bcf1e3a37f16?w=1263&amp;h=222&amp;f=png&amp;s=49982" alt="img"></p>
<p>看到这里，是不是心痒痒？具体的安装方法参照官方 <a href="https://github.com/lukechilds/zsh-better-npm-completion" target="_blank" rel="noopener">README.md</a> 文件就好，我就不在这里啰嗦了。</p>
<blockquote>
<p><strong>TIP#12</strong>：如果你要使用 zsh-better-npm-completion 插件，需要把 .bashrc、.zshrc 文件里面 npm completion 部分的配置删掉，避免冲突。</p>
</blockquote>
<hr>
<p><strong>好了，本小节没有代码，读到这里，你动手做了几个？</strong></p>
<hr>
<h2 id="20171206-增补：如何实现-yarn-的命令自动补全？"><a href="#20171206-增补：如何实现-yarn-的命令自动补全？" class="headerlink" title="20171206 增补：如何实现 yarn 的命令自动补全？"></a>20171206 增补：如何实现 yarn 的命令自动补全？</h2><p>已经有人帮我们做好了 <a href="https://github.com/mklabs/yarn-completions" target="_blank" rel="noopener">yarn-completions</a>，能实现类似于 zsh-better-npm-completion 的命令补全，参照官方 README.md 安装即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">赵小金</p>
              <p class="site-description motion-element" itemprop="description">赵小金的博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赵小金</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
